// Inspiration based off of https://donjon.bin.sh/d20/dungeon/
// Their source code (written in Perl) can be found at https://donjon.bin.sh/code/dungeon/dungeon.pl

/** 
 * HOW THEIRS WORKS:
 * -----------------
 * A dungeon is constructed as a two-dimensional matrix of integers, each representing one cell. Within an integer, each bit indicates a different state, such as 0x01 for blocked cells, 0x02 for cells in rooms, and 0x04 for cells in corridors. Rooms and corridors always fall along odd-numbered columns and rows, and rooms are always odd numbers in width and height.
 * Rooms are placed randomly or by algorithm. If a room does not collide with a blocked cell, another room, etc. then the room and its perimeter are marked out in the matrix. Next, the generator calculates a reasonable number of entrances based on the room size, and attempts to open that number of entrances in the room perimeter.
 * The corridor generator is a simple recursive algorithm with a few quirks. Labyrinth corridors are generated by shuffling the list of directions randomly, errant corridors continue in the current direction 50% of the time, and straight corridors continue 90% of the time.
 */

var dungeon = [];
var dungeonWidth = 16;
var dungeonHeight = 10;
var sensitivity = 8;//MUST BE BETWEEN 0 AND 9 (inclusive)
var seed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);

function generate(){
	//Get values
	if(document.getElementById("cSeed").checked){
		seed = Number(document.getElementById("sSeed").value);
	} else {
		seed = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
		document.getElementById("sSeed").value = seed;
	}
	
	//Lay out board
	dungeon = [];
	let tileChance = [];
	for(let s = 0; s < seed.toString().length; s++){
		tileChance.push(+seed.toString().charAt(s));
	}
	for(let h = 0; h < dungeonHeight; h++){
		let row = [];
		for(let w = 0; w < dungeonWidth; w++){
			row.push([0]);
		}
		dungeon.push(row);
	}
	for(let t = 0; t < dungeonWidth * dungeonHeight; t++){
		let tileRow = Math.floor(t / dungeonWidth);
		let tileCol = t % dungeonHeight;
		let i = (t + tileChance[t % tileChance.length]);
		console.log(i);
		if(tileChance[i % tileChance.length] >= sensitivity){
			//Room opportunity
			console.log("test");
			dungeon[tileRow][tileCol] = 1;
		}
	}
	
	//Draw on board
	const canvas = document.getElementById("canvas").getContext("2d");
	let canvElem = document.getElementById("canvas").getBoundingClientRect();
	let canvSize = 0;
	let tileSize = 0;
	//Measure canvas and tiles
	if(canvElem.width < canvElem.height){
		//Width is smaller than height
		canvSize = canvElem.width;
		tileSize = canvSize / dungeonWidth;
		if(tileSize * dungeonHeight > canvElem.height){
			tileSize = canvSize / dungeonHeight;
		}
	} else {
		//Height is smaller than width. Or they are equal, but it doesn't matter at that point though
		canvSize = canvElem.height;
		tileSize = canvSize / dungeonHeight;
		if(tileSize * dungeonWidth > canvElem.width){
			tileSize = canvSize / dungeonWidth;
		}
	}
	//Actually draw the canvas
	canvas.fillStyle = "white";
	canvas.fillRect(0, 0, canvElem.width, canvElem.height);
	for(let h = 0; h < dungeonHeight; h++){
		for(let w = 0; w < dungeonWidth; w++){
			//Set color
			if(dungeon[h][w] == 0){
				canvas.fillStyle = "white";
			} else if(dungeon[h][w] == 1){
				canvas.fillStyle = "black";
			} else if(dungeon[h][w] == 2){
				canvas.fillStyle = "gray";
			} else {
				canvas.fillStyle = "red";
			}
			//Draw rectangle
			canvas.fillRect(tileSize * w, tileSize * h, tileSize, tileSize);
		}
	}
	canvas.strokeStyle = "black";
	canvas.lineWidth = 2;
	canvas.strokeRect(1, 1, (tileSize * dungeonWidth) - 2, (tileSize * dungeonHeight) - 2);
}